
Session 1
=========

pre-scripted .from_csv() commands
titles

Length, Head, Tail

len(titles)
titles.head() and .head(20)
titles.tail() and .tail(10)

Filtering

h['year'] or h.year
h.year.size   does this even no

h.year + 1000
h.year - 2000

h.year > 1960
h[h.year > 1960]
h[h.year > 1960 & h.year < 1970]
h[(h.year > 1960) & (h.year < 1970)]
h[h.title == '...']

Sorting

titles.sort(['title'])
titles.sort(['year'])
titles.sort(['year', 'title'])

String methods

h.str.startswith
h.str.endswith
h.str.extract
.dt.*

Session 2
=========

Simple aggregation

# h.year.min()
# h.year.max()
# h.year.mean()
h.value_counts()

(While doing exercises:)

true_false.sum() ?

cast.columns ?

v.index
v.values
v.plot()  # whoops
s.sort_index()
v.sort_index().plot()

h[['year', 'name']]
h[['year']]

Counting

Session 3
=========

c = cast.set_index(['title'])
c = cast.set_index(['title'])
c = cast.set_index(['title']).sort_index()
%%time c.loc['Sleuth']
%%time cast[cast.title == 'Sleuth']

c = cast.set_index(['title', 'year'])
c = cast.set_index(['title', 'year']).sort_index()
c.loc['Sleuth']
c.loc['Sleuth',1996]
c.loc['Sleuth',1996].sort('n')
c.loc[('Sleuth',1996),'character']
c.loc[('Sleuth',1996),('character','n')]
c.loc[('Sleuth',1996),('character','n')].sort('n')

c.loc[('Sleuth',1972)].sort('n').reset_index('title')
c.loc[('Sleuth',1972)].sort('n').reset_index('year')
c.loc[('Sleuth',1972)].sort('n').reset_index(['title', 'year'])
c.loc[('Sleuth',1972)].sort('n').reset_index()

c.loc['Sleuth'].index

TODO: show that .loc can take a range

c = cast
c.groupby('year').size()
c.groupby(['year', 'type']).size()

i = cast.set_index(['year', 'type']).sort_index()
i.groupby(level=[0,1]).size()

i = cast.set_index('name').sort_index()
? i.loc['Cary Grant',['year','n']].groupby('year').first()
? i.loc['Cary Grant',['year','n']].groupby('year').last()
i.loc['Cary Grant',['year','n']].groupby('year').mean().plot(kind='bar')
i.loc['Cary Grant',['year','n']].groupby('year').max().plot(kind='bar')
i.loc['Cary Grant',['year','n']].groupby('year').min().plot(kind='bar')
i.loc['Cary Grant',['year','n']].groupby('year').agg(['min', 'mean', 'max'])
a = i.loc['Cary Grant',['year','n']].groupby('year').agg(['min', 'mean', 'max'])
a.loc[:1942].plot(kind='area', stacked=False)

Session 4
=========

c = cast
#c = c[c.year // 10 == 198]
c = c[c.n <= 3]
c = c.groupby(['year', 'type', 'n']).size()
c = c.unstack(1)
Detour:
  c.swaplevel(0,1).loc[1].plot(ylim=0)
  c.swaplevel(0,1).loc[1].plot(ylim=0, kind='area')
f = c.actor / (c.actor + c.actress)
f = f.unstack()
f.plot(ylim=[0,1])

aa = cast[['year', 'type']].groupby(['year', 'type']).size()
aa = aa.loc[:2014].unstack()
aa.head()

aa.plot()
aa.plot(kind='area')

f = aa.actor / (aa.actor + aa.actress)
f.plot(ylim=[0,1], kind='area')

# Show following maneuver for a real final unstack()?
#
# pd.DataFrame({'row': df.unstack().unstack()}).T

Indexing and grouping has been moving our data left.
"Unstacking" moves it up, to columns!

Session 5
=========

reindex? or what? yeah.
.isnull()
.notnull()
.dropna()
.fillna()

broadcast df['foo'] = 9

Session 6
=========

.info()

Pivot

r = release_dates
r = r[r.title.str.startswith('Star Wars: Episode')]
r = r[r.country.str.startswith('U')]
r.pivot('title', 'country', 'date')

which is the same as

r.set_index(['title', 'country'])[['date']].unstack()

.rename(columns={...})
.concat(df)

(who had which co-stars how often)
(what pairs of co-stars have appeared the most often together)
